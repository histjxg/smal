
第六篇：jvm如何处理异常
受检异常和非受检异常
1:使用异常捕获的代码为什么比较耗费性能？
因为构造异常的实例比较耗性能。这从代码层面很难理解，不过站在JVM的角度来看就简单了，因为JVM在构造异常实例时需要生成该异常的栈轨迹。
这个操作会逐一访问当前线程的栈帧，并且记录下各种调试信息，包括栈帧所指向方法的名字，方法所在的类名、文件名，以及在代码中的第几行触发该异常等信息。
虽然具体不清楚JVM的实现细节，但是看描述这件事情也是比较费时费力的。

2:finally是怎么实现无论异常与否都能被执行的？
这个事情是由编译器来实现的，现在的做法是这样的，编译器在编译Java代码时，会复制finally代码块的内容，然后分别放在try-catch代码块所有的正常执行路径及异常执行路径的出口中。

第七篇 jvm如何实现反射的
小结
1:反射机制是Java语言的一个非常重要的特性，通过这个特性，我们能够动态的监控、调用、修改类的行为，许多的框架实现就用到了Java语言反射的机制

2:反射为什么耗费性能？
 原因主要有三个：变长参数方法导致的 Object 数组；基本类型的自动装箱、拆箱；还有最重要的方法内联
逃逸分析  ---栈上分配（始终创建对象，会导致频繁gc）