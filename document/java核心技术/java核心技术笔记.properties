第0篇以面试为切入点的内容
    Java基础:我会围绕Java语言基本特性和机制，由点带面，让你构建牢固的Java技术工底。
    Java进阶:将围绕并发编程、Java虚拟机等领域展开，助你攻坚大厂Java面试的核心阵地
    Java应用开发扩展:从数据库编程、主流开源框架、分布式开发等，帮你掌握Java开发的十八般兵器。
    Java安全基础:让你理解常见的应用安全问题和处理方法，掌握如何写出符合大厂规范的安全代码。
    Java性能基础:你将掌握相关工具、方法论与基础实践。

第一篇的内容：java平台的理解
    Java特性:
    面向对象(封装，继承，多态)
    平台无关性(JVM运行.class文件)
    语言(泛型，Lambda)
    类库(集合，并发，网络，IO/NIO)
    JRE(Java运行环境，JVM，类库)
    JDK(Java开发工具，包括JRE，javac，诊断工具)
    Java是解析运行吗?
    不正确!
    1，Java源代码经过Javac编译成.class文件
    2，.class文件经JVM解析或编译运行。
    (1)解析:.class文件经过JVM内嵌的解析器解析执行。
    (2)编译:存在JIT编译器(Just In Time Compile 即时编译器)把经常运行的代码作为"热点代码"编译与本地平台相关的机器码，并进行各种层次的优化。
    (3)AOT编译器: Java 9提供的直接将所有代码编译成机器码执行。


第15篇的synchronized和ReenTrantlock有什么区别
    线程安全的定义：线程安全是一个多线程环境下正确性的概念，也就是保证多线程环境下共享的、可修改的状态的正确性，这里的状态反映在程序中其实可以看作是数据。

    保证线程安全的两个办法：
    封装:通过封装，我们可以将对象内部状态隐藏、保护起来。
    不可变:还记得我们在专栏第3讲强调的fnal和immutable吗，就是这个道理，Java语言目前还没有真正意义上的原生不可变，但是未来也许会引入。

    线程安全三个特性：状态==数据
    原子性，简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现。
    可见性，是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，volatile就是负责保证可见性的。
    有序性，是保证线程内串行语义，避免指令重排等。

    ReentrantLock是Lock的实现类，是一个互斥的同步器，在多线程高竞争条件下，ReentrantLock比synchronized有更加优异的性能表现。
    1 用法比较
    Lock使用起来比较灵活，但是必须有释放锁的配合动作
    Lock必须手动获取与释放锁，而synchronized不需要手动释放和开启锁
    Lock只适用于代码块锁，而synchronized可用于修饰方法、代码块等 
    2 特性比较
    ReentrantLock的优势体现在:
    具备尝试非阻塞地获取锁的特性:当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁
    能被中断地获取锁的特性:与synchronized不同，获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放
    超时获取锁的特性:在指定的时间范围内获取锁;如果截止时间到了仍然无法获取锁，则返回
    3 注意事项
    在使用ReentrantLock类的时，一定要注意三点:
    在fnally中释放锁，目的是保证在获取锁之后，最终能够被释放
    不要将获取锁的过程写在try块内，因为如果在获取锁时发生了异常，异常抛出的同时，也会导致锁无故被释放。
    ReentrantLock提供了一个newCondition的方法，以便用户在同一锁的情况下可以根据不同的情况执行等待或唤醒的动作。